---
phase: 02-product-ingestion-embeddings
plan: 05
type: execute
depends_on: ["02-01", "02-02", "02-03", "02-04"]
files_modified: [apps/backend/src/features/products/service/ingestion_service.py, apps/backend/src/features/products/service/product_repository.py, apps/backend/src/features/products/router/router.py]
domain: backend
---

<objective>
Create product ingestion pipeline that orchestrates quality validation, embedding generation, and storage.

Purpose: Provide end-to-end product ingestion that validates images, generates embeddings, and stores in both PostgreSQL and Qdrant.
Output: IngestionService that coordinates all components, ProductRepository for database operations, ingestion router.
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-plan.md
./summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/02-product-ingestion-embeddings/02-01-SUMMARY.md
@.planning/phases/02-product-ingestion-embeddings/02-02-SUMMARY.md
@.planning/phases/02-product-ingestion-embeddings/02-03-SUMMARY.md
@.planning/phases/02-product-ingestion-embeddings/02-04-SUMMARY.md
@apps/backend/src/features/ai/service/embedding_service.py
@apps/backend/src/features/ai/service/quality_gate.py
@apps/backend/src/features/products/service/woocommerce_client.py
@apps/backend/src/models/product.py
@apps/backend/src/core/qdrant.py

**Established patterns:**
- AsyncQdrantClient for vector storage
- SQLAlchemy async sessions
- Feature folder convention
**Architecture from PROJECT.md:**
- Qdrant is single source of truth for embeddings
- PostgreSQL stores product metadata
- Synchronous inference with semaphore limiting
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create product repository and ingestion service</name>
  <files>apps/backend/src/features/products/service/product_repository.py, apps/backend/src/features/products/service/ingestion_service.py</files>
  <action>
Create ProductRepository in product_repository.py:

```python
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy import select
from uuid import UUID
from ...models.product import Product
from ..schemas.schemas import ProductCreate

class ProductRepository:
    def __init__(self, session: AsyncSession):
        self.session = session

    async def create(self, data: ProductCreate) -> Product:
        """Create new product in PostgreSQL."""
        product = Product(
            external_id=data.external_id,
            store_id=data.store_id,
            title=data.title,
            description=data.description,
            price=data.price,
            currency=data.currency,
            image_url=data.image_url,
            product_url=data.product_url
        )
        self.session.add(product)
        await self.session.flush()
        return product

    async def get_by_external_id(self, external_id: str, store_id: str) -> Product | None:
        """Check if product already exists."""
        result = await self.session.execute(
            select(Product).where(
                Product.external_id == external_id,
                Product.store_id == store_id
            )
        )
        return result.scalar_one_or_none()

    async def exists(self, external_id: str, store_id: str) -> bool:
        """Check if product exists (faster than get)."""
        result = await self.session.execute(
            select(Product.id).where(
                Product.external_id == external_id,
                Product.store_id == store_id
            ).limit(1)
        )
        return result.scalar_one_or_none() is not None
```

Create IngestionService in ingestion_service.py:

```python
from dataclasses import dataclass
from PIL import Image
from io import BytesIO
import httpx
import logging
from uuid import UUID

from qdrant_client import AsyncQdrantClient
from qdrant_client.models import PointStruct

from ..schemas.schemas import ProductCreate, ProductSyncStatus
from .product_repository import ProductRepository
from ...ai.service.embedding_service import EmbeddingService
from ...ai.service.quality_gate import QualityGateService, QualityIssue

logger = logging.getLogger(__name__)

@dataclass
class IngestionResult:
    success: bool
    product_id: UUID | None = None
    error: str | None = None
    quality_issues: list[str] | None = None

class IngestionService:
    def __init__(
        self,
        repository: ProductRepository,
        embedding_service: EmbeddingService,
        quality_gate: QualityGateService,
        qdrant_client: AsyncQdrantClient,
        collection_name: str = "products"
    ):
        self.repository = repository
        self.embedding_service = embedding_service
        self.quality_gate = quality_gate
        self.qdrant = qdrant_client
        self.collection_name = collection_name

    async def ingest_product(self, product_data: ProductCreate) -> IngestionResult:
        """
        Full ingestion pipeline:
        1. Check if product already exists
        2. Fetch and validate image quality
        3. Generate embedding
        4. Store in PostgreSQL and Qdrant
        """
        # Check for duplicate
        if await self.repository.exists(product_data.external_id, product_data.store_id):
            return IngestionResult(success=False, error="Product already exists")

        # Fetch image
        try:
            image, file_size = await self._fetch_image(product_data.image_url)
        except Exception as e:
            logger.warning(f"Failed to fetch image {product_data.image_url}: {e}")
            return IngestionResult(success=False, error=f"Image fetch failed: {str(e)}")

        # Validate quality
        quality_result = self.quality_gate.validate_image(image, file_size)
        if not quality_result.passed:
            return IngestionResult(
                success=False,
                error="Quality check failed",
                quality_issues=[issue.value for issue in quality_result.issues]
            )

        # Generate embedding
        try:
            embedding = await self.embedding_service.get_embedding(image)
        except Exception as e:
            logger.error(f"Embedding generation failed: {e}")
            return IngestionResult(success=False, error=f"Embedding failed: {str(e)}")

        # Store in PostgreSQL
        product = await self.repository.create(product_data)

        # Store embedding in Qdrant
        await self.qdrant.upsert(
            collection_name=self.collection_name,
            points=[
                PointStruct(
                    id=str(product.id),
                    vector=embedding,
                    payload={
                        "product_id": str(product.id),
                        "store_id": product.store_id,
                        "price": float(product.price),
                        "created_at": product.created_at.isoformat()
                    }
                )
            ]
        )

        return IngestionResult(success=True, product_id=product.id)

    async def _fetch_image(self, url: str) -> tuple[Image.Image, int]:
        """Fetch image from URL, return PIL Image and file size."""
        async with httpx.AsyncClient(timeout=30.0) as client:
            response = await client.get(url)
            response.raise_for_status()
            data = response.content
            return Image.open(BytesIO(data)), len(data)
```
  </action>
  <verify>cd apps/backend && python -c "from src.features.products.service.ingestion_service import IngestionService, IngestionResult; from src.features.products.service.product_repository import ProductRepository; print('Ingestion service OK')"</verify>
  <done>IngestionService orchestrates quality gate, embedding, and storage; ProductRepository handles DB operations</done>
</task>

<task type="auto">
  <name>Task 2: Create ingestion router with endpoints</name>
  <files>apps/backend/src/features/products/router/__init__.py, apps/backend/src/features/products/router/router.py, apps/backend/src/main.py</files>
  <action>
Create router in features/products/router/router.py:

```python
from fastapi import APIRouter, Depends, HTTPException, BackgroundTasks
from sqlalchemy.ext.asyncio import AsyncSession
from typing import Annotated

from ..schemas.schemas import ProductCreate, ProductResponse, ProductSyncStatus
from ..service.ingestion_service import IngestionService, IngestionResult
from ..service.product_repository import ProductRepository
from ...ai.service.quality_gate import QualityGateService
from ....core.database import get_session
from ....core.qdrant import get_qdrant_client

router = APIRouter(prefix="/api/products", tags=["products"])

@router.post("/ingest", response_model=dict)
async def ingest_single_product(
    product: ProductCreate,
    session: Annotated[AsyncSession, Depends(get_session)],
    # Note: embedding_service and qdrant_client come from app.state
):
    """Ingest a single product (for testing/manual ingestion)."""
    from fastapi import Request
    # This endpoint is primarily for testing
    # Full batch ingestion uses the sync endpoint
    ...

@router.get("/count")
async def get_product_count(
    session: Annotated[AsyncSession, Depends(get_session)]
):
    """Get total product count from PostgreSQL."""
    from sqlalchemy import func, select
    from ....models.product import Product
    result = await session.execute(select(func.count(Product.id)))
    return {"count": result.scalar()}

@router.get("/health")
async def products_health():
    """Health check for products feature."""
    return {"status": "ok", "feature": "products"}
```

Add dependency injection helper to get IngestionService with all dependencies wired up.

Include products router in main.py.
  </action>
  <verify>cd apps/backend && python -c "from src.features.products.router.router import router; print('Products router OK')"</verify>
  <done>Products router created with ingestion endpoint, count endpoint, and health check</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] IngestionService can be instantiated with all dependencies
- [ ] ProductRepository CRUD operations work
- [ ] GET /api/products/count returns product count
- [ ] GET /api/products/health returns ok
</verification>

<success_criteria>

- Ingestion pipeline orchestrates: fetch → validate → embed → store
- Products stored in both PostgreSQL (metadata) and Qdrant (embeddings)
- Duplicate detection prevents re-ingestion
- Quality gate rejects invalid images before embedding
- All 02-01 through 02-04 components integrated
</success_criteria>

<output>
After completion, create `.planning/phases/02-product-ingestion-embeddings/02-05-SUMMARY.md`
</output>
