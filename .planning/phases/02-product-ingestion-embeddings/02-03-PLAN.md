---
phase: 02-product-ingestion-embeddings
plan: 03
type: execute
depends_on: []
files_modified: [apps/backend/src/features/ai/service/quality_gate.py, apps/backend/src/features/ai/schemas/schemas.py, apps/backend/src/features/ai/router/router.py]
domain: backend
---

<objective>
Implement image quality gate service for validating product images before embedding generation.

Purpose: Block blurry, too-small, or invalid images that would pollute style vectors and degrade recommendation quality.
Output: QualityGateService with blur detection, dimension validation, and size checks.
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-plan.md
./summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@apps/backend/src/features/ai/service/embedding_service.py
@apps/backend/src/features/ai/schemas/schemas.py

**Tech stack available:** OpenCV (cv2), Pillow, numpy
**Quality requirements from PROJECT.md:**
- Dimensions: 400px minimum on smallest side
- File size: 50KB - 10MB
- Blur detection: Laplacian variance threshold

**Research findings:**
- Laplacian variance method: cv2.Laplacian(gray, cv2.CV_64F).var()
- Threshold ~100 (lower = blurry, higher = sharp)
- Normalize image size before blur check for consistent scores
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create image quality gate service</name>
  <files>apps/backend/pyproject.toml, apps/backend/src/features/ai/service/quality_gate.py</files>
  <action>
Add opencv-python-headless to pyproject.toml (headless = no GUI dependencies).

Create QualityGateService in features/ai/service/quality_gate.py:

```python
import cv2
import numpy as np
from PIL import Image
from dataclasses import dataclass
from enum import Enum

class QualityIssue(str, Enum):
    TOO_SMALL = "too_small"
    TOO_LARGE = "too_large"
    TOO_BLURRY = "too_blurry"
    INVALID_FORMAT = "invalid_format"

@dataclass
class QualityResult:
    passed: bool
    issues: list[QualityIssue]
    blur_score: float | None = None
    width: int | None = None
    height: int | None = None
    file_size_bytes: int | None = None

class QualityGateService:
    def __init__(
        self,
        min_dimension: int = 400,
        min_file_size: int = 50 * 1024,      # 50KB
        max_file_size: int = 10 * 1024 * 1024,  # 10MB
        blur_threshold: float = 100.0,
        normalize_size: int = 500  # Normalize to this size for blur check
    ):
        self.min_dimension = min_dimension
        self.min_file_size = min_file_size
        self.max_file_size = max_file_size
        self.blur_threshold = blur_threshold
        self.normalize_size = normalize_size

    def validate_image(self, image: Image.Image, file_size_bytes: int | None = None) -> QualityResult:
        """Validate image quality. Returns QualityResult with pass/fail and issues."""
        issues = []
        width, height = image.size

        # Dimension check
        min_side = min(width, height)
        if min_side < self.min_dimension:
            issues.append(QualityIssue.TOO_SMALL)

        # File size check (if provided)
        if file_size_bytes is not None:
            if file_size_bytes < self.min_file_size:
                issues.append(QualityIssue.TOO_SMALL)
            elif file_size_bytes > self.max_file_size:
                issues.append(QualityIssue.TOO_LARGE)

        # Blur detection
        blur_score = self._calculate_blur_score(image)
        if blur_score < self.blur_threshold:
            issues.append(QualityIssue.TOO_BLURRY)

        return QualityResult(
            passed=len(issues) == 0,
            issues=issues,
            blur_score=blur_score,
            width=width,
            height=height,
            file_size_bytes=file_size_bytes
        )

    def _calculate_blur_score(self, image: Image.Image) -> float:
        """Calculate Laplacian variance as blur score. Higher = sharper."""
        # Convert to grayscale numpy array
        gray = image.convert('L')

        # Normalize size for consistent scoring
        if max(gray.size) > self.normalize_size:
            ratio = self.normalize_size / max(gray.size)
            new_size = (int(gray.width * ratio), int(gray.height * ratio))
            gray = gray.resize(new_size, Image.Resampling.LANCZOS)

        # Convert to numpy and calculate Laplacian variance
        img_array = np.array(gray)
        laplacian = cv2.Laplacian(img_array, cv2.CV_64F)
        return float(laplacian.var())

    async def validate_from_url(self, image_url: str) -> QualityResult:
        """Fetch image from URL and validate."""
        import httpx
        async with httpx.AsyncClient() as client:
            response = await client.get(image_url, timeout=30.0)
            response.raise_for_status()

            from io import BytesIO
            image_data = response.content
            image = Image.open(BytesIO(image_data))

            return self.validate_image(image, file_size_bytes=len(image_data))
```

Add httpx to dependencies for async HTTP requests.
  </action>
  <verify>cd apps/backend && python -c "from src.features.ai.service.quality_gate import QualityGateService, QualityResult; print('Quality gate OK')"</verify>
  <done>QualityGateService created with blur detection, dimension and size validation</done>
</task>

<task type="auto">
  <name>Task 2: Add quality gate schemas and router endpoint</name>
  <files>apps/backend/src/features/ai/schemas/schemas.py, apps/backend/src/features/ai/router/router.py</files>
  <action>
Add to schemas.py:

```python
class QualityCheckRequest(BaseModel):
    image_url: str = Field(..., description="URL of image to validate")

class QualityCheckResponse(BaseModel):
    passed: bool
    issues: list[str] = Field(default_factory=list)
    blur_score: float | None = None
    width: int | None = None
    height: int | None = None
    file_size_bytes: int | None = None
    thresholds: dict = Field(
        default_factory=lambda: {
            "min_dimension": 400,
            "blur_threshold": 100.0,
            "min_file_size_kb": 50,
            "max_file_size_mb": 10
        }
    )
```

Add endpoint to router.py:
- POST /api/ai/quality-check - Validate image URL, return QualityCheckResponse

Create QualityGateService instance (stateless, can be created per-request or as singleton).
  </action>
  <verify>cd apps/backend && python -c "from src.features.ai.schemas import QualityCheckRequest, QualityCheckResponse; print('Schemas OK')"</verify>
  <done>Quality check endpoint added, schemas created for request/response</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] QualityGateService validates dimensions correctly (rejects <400px)
- [ ] Blur detection returns reasonable scores (sharp images >100, blurry <100)
- [ ] POST /api/ai/quality-check endpoint responds with validation result
- [ ] No new import errors
</verification>

<success_criteria>

- Image quality gate blocks invalid images
- Blur detection uses Laplacian variance method
- Dimension validation enforces 400px minimum
- File size validation enforces 50KB-10MB range
- Quality check endpoint available for testing
</success_criteria>

<output>
After completion, create `.planning/phases/02-product-ingestion-embeddings/02-03-SUMMARY.md`
</output>
