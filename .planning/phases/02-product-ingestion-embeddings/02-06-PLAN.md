---
phase: 02-product-ingestion-embeddings
plan: 06
type: execute
depends_on: ["02-05"]
files_modified: [apps/backend/scripts/seed_bootstrap.py, apps/backend/data/bootstrap_products.json]
domain: backend
---

<objective>
Create bootstrap store seeding script to populate 300-500 curated fashion products for MVP development.

Purpose: Enable development and testing without dependency on partner store availability. Provides immediate product catalog.
Output: Seeding script that ingests curated products, verification that 300+ products exist with embeddings.
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-plan.md
./summary.md
~/.claude/get-shit-done/references/checkpoints.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/02-product-ingestion-embeddings/02-05-SUMMARY.md
@apps/backend/src/features/products/service/ingestion_service.py

**From PROJECT.md:**
- "Bootstrap fallback store (300-500 curated products) to prevent Week 1 dependency block"
- Products need: title, price, image_url, product_url

**Bootstrap strategy:**
- Use publicly available fashion product images from open datasets or free stock
- Alternatively, use placeholder data with real image URLs from fashion sites
- Store ID: "bootstrap" to identify these products
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create bootstrap product data and seeding script</name>
  <files>apps/backend/scripts/__init__.py, apps/backend/scripts/seed_bootstrap.py, apps/backend/data/bootstrap_products.json</files>
  <action>
Create scripts/ directory and data/ directory in apps/backend/.

Create seed_bootstrap.py script:

```python
#!/usr/bin/env python3
"""
Bootstrap store seeding script.

Seeds the database with 300+ curated fashion products for MVP development.
Products are sourced from Unsplash (free, high-quality fashion images).

Usage:
    cd apps/backend
    python -m scripts.seed_bootstrap
"""
import asyncio
import json
import logging
from pathlib import Path

from sqlalchemy.ext.asyncio import create_async_engine, AsyncSession
from sqlalchemy.orm import sessionmaker

from src.core.config import get_settings
from src.core.qdrant import get_qdrant_client, ensure_collection
from src.features.ai.service.embedding_service import EmbeddingService
from src.features.ai.service.quality_gate import QualityGateService
from src.features.products.service.ingestion_service import IngestionService
from src.features.products.service.product_repository import ProductRepository
from src.features.products.schemas.schemas import ProductCreate

logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

BOOTSTRAP_STORE_ID = "bootstrap"

async def load_bootstrap_products() -> list[ProductCreate]:
    """Load products from JSON file or generate programmatically."""
    data_file = Path(__file__).parent.parent / "data" / "bootstrap_products.json"

    if data_file.exists():
        with open(data_file) as f:
            products_data = json.load(f)
        return [ProductCreate(**p, store_id=BOOTSTRAP_STORE_ID) for p in products_data]

    # Generate products using Unsplash fashion images
    # Unsplash allows hotlinking and has excellent fashion photography
    logger.info("Generating bootstrap products from Unsplash...")

    products = []
    categories = [
        ("dress", 80), ("shirt", 60), ("jeans", 50), ("jacket", 40),
        ("shoes", 40), ("bag", 30), ("sweater", 30), ("skirt", 25),
        ("coat", 20), ("accessories", 25)
    ]

    product_id = 1
    for category, count in categories:
        for i in range(count):
            # Unsplash source URL for fashion category
            # These are random high-quality images
            image_url = f"https://source.unsplash.com/featured/800x1000/?{category},fashion&sig={product_id}"

            products.append(ProductCreate(
                external_id=f"bootstrap-{product_id}",
                store_id=BOOTSTRAP_STORE_ID,
                title=f"Fashion {category.title()} #{i+1}",
                description=f"Stylish {category} for your wardrobe",
                price=round(29.99 + (product_id % 20) * 10, 2),  # $29.99 - $229.99
                currency="USD",
                image_url=image_url,
                product_url=f"https://stylipp.com/product/{product_id}"  # Placeholder URL
            ))
            product_id += 1

    return products

async def seed_bootstrap_store():
    """Main seeding function."""
    settings = get_settings()

    # Setup database
    engine = create_async_engine(settings.database_url)
    async_session = sessionmaker(engine, class_=AsyncSession, expire_on_commit=False)

    # Setup services
    logger.info("Loading FashionSigLIP model (may take a moment on first run)...")
    embedding_service = EmbeddingService()
    embedding_service.load_model()

    quality_gate = QualityGateService()
    qdrant_client = await get_qdrant_client()
    await ensure_collection(qdrant_client)

    # Load products
    products = await load_bootstrap_products()
    logger.info(f"Loaded {len(products)} products to seed")

    # Ingest products
    success_count = 0
    fail_count = 0

    async with async_session() as session:
        repository = ProductRepository(session)
        ingestion_service = IngestionService(
            repository=repository,
            embedding_service=embedding_service,
            quality_gate=quality_gate,
            qdrant_client=qdrant_client
        )

        for i, product in enumerate(products):
            result = await ingestion_service.ingest_product(product)

            if result.success:
                success_count += 1
            else:
                fail_count += 1
                if result.quality_issues:
                    logger.debug(f"Rejected {product.external_id}: {result.quality_issues}")
                else:
                    logger.debug(f"Failed {product.external_id}: {result.error}")

            if (i + 1) % 50 == 0:
                await session.commit()
                logger.info(f"Progress: {i+1}/{len(products)} (success: {success_count}, failed: {fail_count})")

        await session.commit()

    logger.info(f"Seeding complete: {success_count} products ingested, {fail_count} failed")

    # Verify Qdrant count
    collection_info = await qdrant_client.get_collection(collection_name="products")
    logger.info(f"Qdrant products collection: {collection_info.points_count} vectors")

    await engine.dispose()

if __name__ == "__main__":
    asyncio.run(seed_bootstrap_store())
```

Create empty bootstrap_products.json as placeholder (script generates if empty):
```json
[]
```
  </action>
  <verify>cd apps/backend && python -c "from scripts.seed_bootstrap import load_bootstrap_products; print('Seed script OK')"</verify>
  <done>Bootstrap seeding script created with Unsplash-based product generation</done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>Bootstrap store seeding with 300+ products and embeddings in Qdrant</what-built>
  <how-to-verify>
    1. Ensure Docker services are running: `cd infra && docker compose up -d`
    2. Run migrations: `cd apps/backend && alembic upgrade head`
    3. Run seeding script: `cd apps/backend && python -m scripts.seed_bootstrap`
    4. Wait for completion (may take 10-15 minutes for 300+ products with embedding generation)
    5. Verify PostgreSQL: Check logs show 300+ successful ingestions
    6. Verify Qdrant: Logs should show "Qdrant products collection: 300+ vectors"
    7. Optional: Query Qdrant directly to confirm embeddings exist
  </how-to-verify>
  <resume-signal>Type "approved" if 300+ products were seeded successfully, or describe any issues</resume-signal>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] Seeding script runs without errors
- [ ] 300+ products exist in PostgreSQL
- [ ] 300+ embeddings exist in Qdrant
- [ ] Products have valid prices, titles, and image URLs
</verification>

<success_criteria>

- Bootstrap store seeded with 300+ products
- Each product has embedding in Qdrant
- Products identified by store_id="bootstrap"
- Seeding script is idempotent (skips existing products)
- Phase 2 complete: Product ingestion pipeline fully functional
</success_criteria>

<output>
After completion, create `.planning/phases/02-product-ingestion-embeddings/02-06-SUMMARY.md`

This completes Phase 2. The summary should include:
- Total products seeded
- Embedding generation performance
- Any quality gate rejections
- Ready for Phase 3 (Clustering & Cold Start)
</output>
