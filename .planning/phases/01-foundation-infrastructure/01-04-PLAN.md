---
phase: 01-foundation-infrastructure
plan: 04
type: execute
depends_on: ["01-02", "01-03"]
files_modified: [infra/docker-compose.yml, infra/postgres/init.sql, apps/backend/.env.example, apps/web/.env.example]
---

<objective>
Create Docker Compose infrastructure with PostgreSQL, Qdrant, and Redis for local development and production deployment.

Purpose: Establish containerized database and vector store infrastructure that both frontend and backend depend on. This provides consistent development environment and production-ready orchestration.
Output: docker-compose up starts all services with health checks, databases are accessible, connection strings configured.
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-plan.md
./summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/01-foundation-infrastructure/01-02-SUMMARY.md
@.planning/phases/01-foundation-infrastructure/01-03-SUMMARY.md

**Databases**: PostgreSQL 16 (user data, analytics), Qdrant 1.7+ (product embeddings), Redis 7 (cache, rate limiting)
**Development ports**: PostgreSQL 5432, Qdrant 6333 (API) + 6334 (gRPC), Redis 6379
**Production**: Services communicate via Docker network, exposed through Traefik
**Server**: david@173.249.48.168:62222
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Docker Compose with PostgreSQL, Qdrant, Redis services</name>
  <files>infra/docker-compose.yml, infra/.env.example</files>
  <action>
    Create infra/docker-compose.yml with services:

    **postgres service:**
    - image: pgvector/pgvector:pg16 (includes pgvector extension, not standard postgres:16-alpine)
    - environment: POSTGRES_DB=stylipp, POSTGRES_USER=stylipp, POSTGRES_PASSWORD from ${POSTGRES_PASSWORD}
    - volumes: postgres_data:/var/lib/postgresql/data, ./postgres/init.sql:/docker-entrypoint-initdb.d/init.sql
    - ports: "5432:5432"
    - healthcheck: pg_isready -U stylipp every 5s
    - restart: unless-stopped

    **qdrant service:**
    - image: qdrant/qdrant:v1.7.4
    - volumes: qdrant_data:/qdrant/storage
    - ports: "6333:6333" (REST API), "6334:6334" (gRPC)
    - healthcheck: curl -f http://localhost:6333/healthz every 10s
    - restart: unless-stopped

    **redis service:**
    - image: redis:7-alpine
    - command: redis-server --appendonly yes
    - volumes: redis_data:/data
    - ports: "6379:6379"
    - healthcheck: redis-cli ping every 5s
    - restart: unless-stopped

    Define named volumes: postgres_data, qdrant_data, redis_data

    Create infra/.env.example with:
    - POSTGRES_PASSWORD=changeme_in_production
    - DATABASE_URL=postgresql+asyncpg://stylipp:${POSTGRES_PASSWORD}@postgres:5432/stylipp
    - QDRANT_URL=http://qdrant:6333
    - REDIS_URL=redis://redis:6379/0
  </action>
  <verify>docker-compose -f infra/docker-compose.yml config validates without errors, services defined with health checks</verify>
  <done>docker-compose.yml created with PostgreSQL, Qdrant, Redis services, health checks configured, volumes defined</done>
</task>

<task type="auto">
  <name>Task 2: Add database initialization scripts and extensions</name>
  <files>infra/postgres/init.sql</files>
  <action>
    Create infra/postgres/init.sql:
    - CREATE EXTENSION IF NOT EXISTS "uuid-ossp"; (for UUID generation)
    - CREATE EXTENSION IF NOT EXISTS "vector"; (for pgvector, minimal MVP use but needed for future)
    - Set timezone to UTC: ALTER DATABASE stylipp SET timezone TO 'UTC';

    This script runs automatically on first container startup via docker-entrypoint-initdb.d mount.
  </action>
  <verify>cat infra/postgres/init.sql shows uuid-ossp and vector extensions</verify>
  <done>PostgreSQL initialization script created with uuid-ossp and pgvector extensions</done>
</task>

<task type="auto">
  <name>Task 3: Configure connection strings and environment variables</name>
  <files>apps/backend/.env.example, apps/web/.env.example</files>
  <action>
    Create apps/backend/.env.example:
    - DATABASE_URL=postgresql+asyncpg://stylipp:changeme@localhost:5432/stylipp
    - QDRANT_URL=http://localhost:6333
    - REDIS_URL=redis://localhost:6379/0
    - SECRET_KEY=dev_secret_change_in_production
    - DEBUG=true
    - CORS_ORIGINS=http://localhost:5173,https://stylipp.com

    Create apps/web/.env.example:
    - VITE_API_URL=http://localhost:8000
    - VITE_APP_NAME=Stylipp

    Add note in both: "Copy to .env and update values for local development"

    Update root .gitignore to include .env files (already done in 01-01, verify):
    - .env
    - .env.local
    - .env.*.local
  </action>
  <verify>apps/backend/.env.example and apps/web/.env.example exist with connection strings; .gitignore contains .env pattern</verify>
  <done>Environment variable templates created for backend and frontend, .gitignore configured to exclude .env files</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `docker-compose -f infra/docker-compose.yml config` validates successfully
- [ ] `docker-compose -f infra/docker-compose.yml up -d` starts all services
- [ ] `docker-compose -f infra/docker-compose.yml ps` shows postgres, qdrant, redis as healthy
- [ ] PostgreSQL accessible: `psql postgresql://stylipp:password@localhost:5432/stylipp -c "SELECT 1;"`
- [ ] Qdrant accessible: `curl http://localhost:6333/healthz` returns "ok"
- [ ] Redis accessible: `redis-cli ping` returns "PONG"
- [ ] init.sql extensions created: `psql -c "\dx"` shows uuid-ossp and vector
</verification>

<success_criteria>

- Docker Compose orchestrates 3 services (PostgreSQL, Qdrant, Redis)
- All services pass health checks
- PostgreSQL has uuid-ossp and pgvector extensions
- Connection strings configured in .env.example files
- Services communicate via Docker network
- Named volumes persist data across restarts
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation-infrastructure/01-04-SUMMARY.md`:

# Phase 1 Plan 4: Docker Infrastructure Summary

**Created Docker Compose orchestration with PostgreSQL, Qdrant, and Redis services for Stylipp**

## Accomplishments

- Configured Docker Compose with 3 core services
- Set up PostgreSQL 16 with uuid-ossp and pgvector extensions
- Configured Qdrant vector database for product embeddings
- Set up Redis for caching and rate limiting
- Created health checks for all services
- Defined connection string templates

## Files Created/Modified

- `infra/docker-compose.yml` - Service orchestration
- `infra/postgres/init.sql` - PostgreSQL initialization with extensions
- `infra/.env.example` - Infrastructure environment variables
- `apps/backend/.env.example` - Backend connection strings
- `apps/web/.env.example` - Frontend environment variables

## Decisions Made

- PostgreSQL 16 for relational data with pgvector for future hybrid queries
- Qdrant as single source of truth for product embeddings (no duplication in PostgreSQL)
- Redis appendonly mode for persistence
- Named volumes for data persistence across container restarts
- Health checks with appropriate intervals (5s for PG/Redis, 10s for Qdrant)

## Issues Encountered

None

## Next Step

Ready for 01-05-PLAN.md (JWT Authentication Scaffold)
</output>
